---
title: '[Java Performance] JVM 线程调优'
date: 2014-10-10 18:09:00
categories: [编程语言, Java]
tags: [Java, Performance, JVM, 线程]
---

## 调整线程栈空间

当非常缺少内存时，可以调整线程使用的内存。每个线程都有一个栈，用来记录该线程的调用栈信息。线程中的栈的默认空间是有OS和JVM的版本决定的：

|OS|	32-bit	|64-bit|
| --- | --- | --- |
|Linux|	320 KB	|1 MB|
|Mac OS|	N/A	|1 MB|
|Solaris Sparc	|512 KB|	1 MB|
|Solaris X86|	320 KB	|1 MB|
|Windows	|320 KB|	1 MB|

当栈空间被设置的过小时，可能会因为有较长的调用栈而抛出StackOverflowError。

<!-- More -->

在64位的JVM中，一般不需要修改这个值，除非内存确实非常吃紧。而在32位的JVM中，可以将这个值从320KB设置成128KB，为了给堆内存腾出更多的空间。

更改线程栈空间的指令：-Xss=N 比如：-Xss=256k

## 偏见锁(Biased Locking)

当锁被多个线程所争夺时，JVM和OS能够选择将锁分配给哪个线程。可以使用一种公平的策略将锁分配给其他线程，或者也可以使用一种不公平(偏见)的策略，比如将锁再分配给上一次拥有该锁的线程。

将锁再次分配给上一次拥有该锁的线程，这样做的合理性在于：由于时间上的连续性，处理器中可能还缓存着和该线程所执行任务相关的数据，因此当线程再次执行时，准备上下文的时间就能够节省下来。当然，使用偏见锁本身需要记录一些相关数据，因此在某些时候反而会对性能有影响。

典型的比如，在很多时候，如果将偏见锁应用在线程池中，那么性能反而会变差。如果一个应用并不需要使用偏见锁来作为锁分配的策略，那么可以通过：-XX:-UseBiasedLocking 来禁用它，因为默认是会启用偏见锁的，禁用它会提升些许性能。

## 锁的自旋(Lock Spinning)

对于没有得到锁的线程，JVM有两种处理方式：

- 让线程进入一个忙循环(Busy Loop)，待它执行了一些指令后会再次检查需要的锁是否可用。
- 让线程进入一个队列，当需要的锁可用时通知它。此时CPU可以被其它线程使用。

如果处于竞争中的锁只需要被持有一小段时间，那么使用第一种忙循环(也被称为线程自旋(Thread Spinning))的速度会比第二种让线程进入队列的方式快的多。反之，当竞争中的锁会被线程持有较长的时间时，使用第二种方式更优，这能够让CPU的有效利用率更高。

JVM会合理地选择使用哪种处理方式。首先会让线程自旋一段时间，如果还没有得到需要的锁，就会将该线程放入队列中等待，从而让出CPU资源给其它线程。

## 线程优先级

在Java API中，每个线程都可以被设置一个优先级，OS会参考这个值。但是注意OS仅仅是“参考”，并不一定会遵循它。OS会对每个运行中的线程计算一个“当前”优先级。这个计算过程会考虑到设置的优先级，但是它仅仅是众多因素中的一个，其中最重要的因素往往是这个线程已经运行了多长时间。考虑这个因素是为了让每个线程都能够得到运行的机会。所以，无论线程被设置的优先级有多低，它们也总能够得到运行的机会。

另外，设置的线程优先级在不同的OS上的权重是不同的。在基于Unix的系统上，线程的执行时间是主导线程当前优先级的因素，也就是说设置的线程优先级几乎不会被“参考”。而在Windows系统上，设置的线程优先级的权重会稍微高一些。

所以，无论是在哪个OS上，应用的性能都不能依赖于对线程设置优先级。如果某些任务的优先级确实高于另外一些任务，那么这一点需要被应用程序的逻辑来完成，而不是通过设置线程的优先级来完成。

一个办法将任务分配给不同的线程池，然后设置这些线程池的规模。


